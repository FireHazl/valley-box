<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Obsessive Valley Box</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #05070a;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }

    #valley-box-container {
      width: 100%;
      height: 100%;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <div id="valley-box-container"></div>

  <!-- Three.js через jsDelivr -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    (function () {
      const container = document.getElementById('valley-box-container');

      if (typeof THREE === 'undefined') {
        container.textContent =
          'Three.js не загрузился. Попробуй позже или с другого устройства.';
        container.style.color = '#eee';
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.justifyContent = 'center';
        container.style.fontFamily =
          'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        container.style.textAlign = 'center';
        return;
      }

      // СЦЕНА
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x05070a);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.z = 3;

      const renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      container.appendChild(renderer.domElement);

      // ПИКСЕЛЬНАЯ ТЕКСТУРА
      function createPixelTexture() {
        const size = 8;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // фон
        ctx.fillStyle = '#0b1020';
        ctx.fillRect(0, 0, size, size);

        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const r = Math.random();
            if (r > 0.84) {
              ctx.fillStyle = '#d8f0ff'; // светлая «звезда»
            } else if (r > 0.72) {
              ctx.fillStyle = '#4a6b88'; // мягкие пятна
            } else {
              continue;
            }
            ctx.fillRect(x, y, 1, 1);
          }
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.magFilter = THREE.NearestFilter;
        texture.minFilter = THREE.NearestFilter;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(2, 2);
        return texture;
      }

      const pixelTexture = createPixelTexture();

      const material = new THREE.MeshStandardMaterial({
        map: pixelTexture,
        roughness: 0.9,
        metalness: 0.0
      });

      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const cube = new THREE.Mesh(geometry, material);
      scene.add(cube);

      // СВЕТ
      const ambient = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambient);

      const directional = new THREE.DirectionalLight(0xffffff, 0.9);
      directional.position.set(2, 3, 4);
      scene.add(directional);

      // ВРАЩЕНИЕ МЫШЬЮ / ПАЛЬЦЕМ
      let isDragging = false;
      let previous = { x: 0, y: 0 };
      let autoRotate = true;

      function toRad(deg) {
        return deg * Math.PI / 180;
      }

      function onPointerDown(clientX, clientY) {
        isDragging = true;
        autoRotate = false;
        previous.x = clientX;
        previous.y = clientY;
      }

      function onPointerMove(clientX, clientY) {
        if (!isDragging) return;

        const deltaX = clientX - previous.x;
        const deltaY = clientY - previous.y;
        const speed = 0.3;

        cube.rotation.y += toRad(deltaX * speed);
        cube.rotation.x += toRad(deltaY * speed);

        previous.x = clientX;
        previous.y = clientY;
      }

      function onPointerUp() {
        isDragging = false;
        autoRotate = true;
      }

      // МЫШЬ
      renderer.domElement.addEventListener('mousedown', function (e) {
        onPointerDown(e.clientX, e.clientY);
      });

      window.addEventListener('mousemove', function (e) {
        if (!isDragging) return;
        onPointerMove(e.clientX, e.clientY);
      });

      window.addEventListener('mouseup', onPointerUp);

      // ТАЧ
      renderer.domElement.addEventListener(
        'touchstart',
        function (e) {
          if (e.touches.length !== 1) return;
          const t = e.touches[0];
          onPointerDown(t.clientX, t.clientY);
        },
        { passive: true }
      );

      window.addEventListener(
        'touchmove',
        function (e) {
          if (!isDragging || e.touches.length !== 1) return;
          const t = e.touches[0];
          onPointerMove(t.clientX, t.clientY);
        },
        { passive: true }
      );

      window.addEventListener(
        'touchend',
        function () {
          if (!isDragging) return;
          onPointerUp();
        },
        { passive: true }
      );

      // АНИМАЦИЯ
      function animate() {
        requestAnimationFrame(animate);

        if (autoRotate && !isDragging) {
          cube.rotation.y += 0.0035;
          cube.rotation.x += 0.0018;
        }

        renderer.render(scene, camera);
      }
      animate();

      // РЕСАЙЗ
      window.addEventListener('resize', function () {
        const w = window.innerWidth;
        const h = window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      });
    })();
  </script>
</body>
</html>
